# =========================
# Flight state monitoring
# monitor_state is called after search_and_set_parameter completes dragging
# Returns (uncontrolled_bool, max_alt)
# =========================
def monitor_state(master, duration=OBSERVE_TIME, param_name=None):
    last_heartbeat = time.time()
    last_print = 0
    current_mode = None
    mission_idx = None
    lat = lon = alt = None
    max_alt = 0.0
    uncontrolled = False

    start_time = time.time()
    if param_name:
        print(f"[Monitor] Start monitoring flight status, observe {duration} seconds (param: {param_name})")
    else:
        print(f"[Monitor] Start monitoring flight status, observe for {duration} seconds")

    while time.time() - start_time < duration:
        msg = master.recv_match(blocking=True, timeout=1)
        now = time.time()
        if not msg:
            continue
        msg_type = msg.get_type()
        if msg_type == "HEARTBEAT":
            last_heartbeat = now
            try:
                current_mode = mavutil.mode_string_v10(msg)
            except Exception:
                current_mode = None
        if msg_type == "MISSION_CURRENT":
            mission_idx = msg.seq
        if msg_type == "GLOBAL_POSITION_INT":
            lat = msg.lat / 1e7
            lon = msg.lon / 1e7
            alt = msg.relative_alt / 1000.0
            max_alt = max(max_alt, alt)
        if msg_type == "ATTITUDE":
            roll = abs(msg.roll)
            pitch = abs(msg.pitch)
            if roll > SAFE_ROLL or pitch > SAFE_PITCH:
                print(f"[Alarm] Attitude exceeds the limit! roll={math.degrees(roll):.1f}°, pitch={math.degrees(pitch):.1f}°")
                try:
                    master.set_mode(master.mode_mapping().get("HOLD"))
                except Exception:
                    pass
                uncontrolled = True
                break
        if now - last_heartbeat > HEARTBEAT_TIMEOUT:
            print("[Alarm] Heartbeat loss > 3 seconds, suspected loss of connection! ")
            try:
                master.set_mode(master.mode_mapping().get("HOLD"))
            except Exception:
                pass
            last_heartbeat = now
            uncontrolled = True
            break
        if alt is not None and alt > MAX_ALT:
            print(f"[Alarm] Altitude too high ({alt:.1f} m) -> judged as out of control")
            uncontrolled = True
            break
        if now - last_print >= 1:
            last_print = now
            if lat is not None and lon is not None and alt is not None:
                if param_name:
                    print(f"[status] parameter={param_name}, mode={current_mode}, mission_idx={mission_idx}, "
                          f"lat={lat:.7f}, lon={lon:.7f}, alt={alt:.2f} m")
                else:
                    print(f"[Status] mode={current_mode}, mission_idx={mission_idx}, "
                          f"lat={lat:.7f}, lon={lon:.7f}, alt={alt:.2f} m")
            else:
                print(f"[Status] mode={current_mode}, mission_idx={mission_idx}, waiting for position data...")

    return uncontrolled, max_alt

def wait_for_landing(master, check_interval=2):
    """
    Wait for the aircraft to land safely (alt < 0.5 m or LAND mode)
    """
    print("[Waiting] Aircraft out of control, waiting for safe landing...")
    while True:
        msg = master.recv_match(blocking=True, timeout=1)
        if not msg:
            time.sleep(check_interval)
            continue

        msg_type = msg.get_type()
        alt = None
        mode = None

        if msg_type == "GLOBAL_POSITION_INT":
            alt = msg.relative_alt / 1000.0 # Convert to meters

        if msg_type == "HEARTBEAT":
            try:
                mode = mavutil.mode_string_v10(msg)
            except Exception:
                mode = None

        if alt is not None and alt <= 0.5:
            print(f"[Landing Completed] Altitude {alt:.2f} m, safe landing")
            break
        elif mode and "LAND" in mode:
            print(f"[Landing Mode] Current mode {mode}, waiting for landing to complete")
            # Can continue to monitor altitude as needed
        time.sleep(check_interval)
